CALCULATOR

INTERFACE
- The UI has a "screen" for displaying values. It has two rows/sections:
    - The upper, smaller row, represents the current calculation chain
    - The lower, larger row, represents the current value being entered
- The UI has buttons for all controls, which have been defined as belonging to one of five
groups:
    - Global controls
    - Operands
    - Modifiers
    - Operators
    - Evaluate

OVERVIEW
- The program has a class for entries, and a class for the calculation chain
- When the calculator starts, it initiates an entry class, with a value of zero
- There is not yet a calculation chain; successive entries and operators are added to the 
calculation in a heap structure
- The calculation holds up to two entries at a time; initialising any subsequent entries 
automatically evaluates the result of the previous two, stores the result as the "previous"
entry, and displays this on the top pane
- As such, you will only ever have one extant calculation object, and a maximum of two entry
objects, at a given time

GLOBAL CONTROLS
C - Resets calculator
CE - Resets current entry to 0
⌫ - While in entry stage, deletes most recently entered character (only if any have been 
entered, else inert)

OPERAND STAGE
// DECIMAL POINT & ALL NUMERIC CHARACTERS
- All numeric characters and the decimal point are considered "operand" characters
- During it's initial phase, an entry is in "operand stage" (or, entry stage), where it will remain 
as long as only operands are pressed
- If the calculator has just been reset, the starting value is zero (as mentioned above)
- If we have re-entered operand stage following on from a previous calculation, the default value
is the previous result (more on that to follow)
- If the first button pressed is a:
    - Zero, then resets the entry value to zero
    - A 1-9 digit, then this overwrites the zero/default value. From then on, any subsequent 
    digits (including zero) are concatenated to the end of the entry value
    - A decimal point, then this resets to zero and concatenates a decimal point after the zero
- The decimal point differs from the other operands, in that it can only appear once within a given
entry value
- Operand stage is reset if the entry is reset (C/CE)
- Operand stage ends when either:
    - A modifier is pressed; it then enters modifier stage (the entry is pushed to the calculation, 
    but is not yet fully closed, and is still editable by modifiers only - not operands)
    - An operator is pressed; it enters operator stage, the entry is closed and pushed to the 
    calculation, along with the new operator (the operator remains interchangeable, until a new 
    entry is opened or the calculation is closed/completed)

MODIFIER STAGE
// PERCENTAGE, RECIPROCAL, SQUARE, SQUARE-ROOT & TOGGLE-PARITY
- Modifiers "modify" the current entry
- Once a modifier is selected during an entry, operand stage is over, and the calculator enters 
modifier stage*

Modifier behaviours:
    - Percentage divides the current entry value by 100 (converts it to it's percentage equivalent). 
    This only works as intended for the second entry onward (see asterisk clause below)
    - Reciprocal converts the number into a unit fraction i.e. 1 divided by the previous value (does 
    not work if value is zero, see asterisk clause)
    - Square exponentiates the value by order of 2
    - Square-root exponentiates the value by order of -1

* The exceptions to this are:
    - if it is the first entry, percentage just resets the value to zero. It is then back in entry 
    stage
    - if the current entry value is zero, percentage does nothing (or, in effect, resets the entry 
    value to zero). It is then back in entry stage
    - if the current entry value is zero, reciprocal produces an error - "INVALID" - and ends the 
    calculation (cannot divide by zero). You will need to then reset to entry stage yourself, by 
    either entering some operands, or hitting reset/backspace/equals
        - Maybe have divide-zero error as it's own state? Or an error state? Same for overflow

- As modifier stage activates, the entry value as it stands is pushed to the calculation. But it is 
still editable, albeit only by valid modifiers (the entry is now "closed" to further operands)
- CE will still reset the current entry to zero, negating any modifiers, if pressed during modifier 
stage
- Modifiers can "stack" for a given entry. If you add a square root to a value, you can then do the 
square root of the resulting value, or switch it to negative, or to a percentage, and so on
- The modifiers as they appear on the calculation panel are figurative representations of 
themselves
    - E.g. you type 4, then square-root it; on the entry pane you see 2, on the calculation pane 
    you see sqrt(4)
- If you do stack the modifiers, the figurative representation encapsulates the previous value**
- Take the following example:
    - You enter 3, then square root it, then square it, the reciprocal it, then switch it's 
    polarity to negative
    - The entry display will first show 3, then 1.732..., then 3 again, then 0.333..., then -0.333...
    - Whereas the calculation pane will show:

        negate(1/(sqr(√(3)))) 
        
    - ...where each modifier's symbol set "wraps" around the previous, at each step 
    - This serves to demonstrate how the calculation pane is not a value store, merely a 
    representation

** The exception to this is again, percentage, which when used on a valid value (2nd or subsequent
entry) will "flatten" the representation in the calculation pane to the current resulting value

- Modifier stage finishes when an operator (+/-/÷/x) is pressed, at which point we enter "operator" 
stage

OPERATOR STAGE
// ADD, SUBTRACT, DIVIDE & MULTIPLY
- Once operator stage is active, the previous entry is pushed to the calculation pane, and is "locked
in"
- A new entry is initialised
- The final value of the previous entry is still present in the entry pane. This is the default
starting value of the new entry. If you press Equals, a modifier, or an operator, it will treat This
as the value of the second entry, and act accordingly
- However, if you start typing new operands, it will erase this default entry value, treating it the
same as the initial "zero value" when you start the first entry in a calculation. This becomes the
value of the new entry
- The operator that was pressed is the current one "staged" for calculation. It can be switched out
for a different one: they cannot "stack" like the modifiers. Only one operator between two entries
- The operator can only be switched out before the value of the new entry is manually altered, i.e.
when the aforementioned "cloned" value from the previous entry is still visible. This is how you
know you are still in "operator stage". Once you alter the entry, you are either back in entry stage,
or modifier stage, depending upon what you pressed
- Entering a subsequent operator (2nd or more in the calculation) after a new entry stage works the 
same as pressing equals - the result is pushed to both the entry pane (as the next default operand)
and to the calculation pane

EQUALS / EVALUATION
- Equals pushes the most recent entry to the calculation, and evaluates the result of the calculation
- It resets the calculator to entry stage, with the evaluated result of the calculation displayed in
the entry pane
- The previous calculation is wiped/reset. The previous calculation is still shown until you make any
further inputs, but it is not factored into any following calculation - the result is
- The entry behaves exactly the same as when you enter operator stage from here, as the
"cloned" value (the result) is now the default value for the next entry. Again, this can be
"picked up" by hitting an operator or modifier, or "dropped", by entering new operands
- From here, the calculator cycles through the behaviours as previously described

...and the world keeps turning, baby!


MISC NOTES===========================================================================================

Entry Object Properties
- Active/inactive
    - private bool property: #active
    - getter
    - setter with error handling (must be bool)
    - constructor uses setter
- Value
    - private number property: #value
    - getter
    - setter (validates if number)
    - constructor uses setter
- Representation string (dictates how the operand entry is shown in the calculation display)
    - private string property: #value
    - getter
    - setter (validates if string)
    - constructor uses setter
- Buffer (array to store inputted digits during entry mode. Automatically updates value when changed)
    - private array property: #buffer
    - append() pushes new digit to end (rejects decimal if already present)
    - convertToValue() joins the array together (first as a string, then casts to number), and updates this.value
    - createFromValue() updates the buffer 
    - negate() puts a minus sign at the start
- Mode (stage)
    - private string property: #mode
    - getter
    - setter with error handling (must be in valid mode array)
    - constructor uses setter
    - static array for valid modes ["new", "entry", "modifier", "operator"]
- Operator
    - private string property: #operator
    - getter
    - setter with error handling (must be in valid operator array)
    - static array for valid operators

Calculation Object Properties
- Active/inactive
    - private bool property: #active
    - getter
    - setter with error handling (must be bool)
    - constructor uses setter
- Chain
    - private array property: #chain (array of calculation objects)
    - getter
    - setter with error handling (must be calculationEntry object)
        - setter checks if last calculationEntry object's operator is "equals", if so, calls this.setResult()
    - constructor uses setter
- Result
    - private number property: #result
    - getter
    - setter (triggered by method on this.chain)
    - constructor uses setter
- Display string
    - private number property: #result
    - getter
    - setter (triggered by method on this.chain)
    - constructor uses setter